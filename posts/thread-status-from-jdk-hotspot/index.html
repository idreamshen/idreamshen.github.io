<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>从 JDK Hotspot 源码探讨线程状态</title>
	
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="从 JDK Hotspot 源码探讨线程状态">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="从 JDK Hotspot 源码探讨线程状态">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://idreamshen.github.io/posts/thread-status-from-jdk-hotspot/">
	<meta name="og:site_name" content="从 JDK Hotspot 源码探讨线程状态">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="https://idreamshen.github.io/css/style.css">
	
	
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-49492756-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

	
	<link rel="stylesheet"
	href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/styles/default.min.css">
	<script 	src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<header>
	
	<a href="https://idreamshen.github.io/" style="float: left;color:#777;"><strong>ChenHsingYu&#39;s Blog</strong></a>
	
	&nbsp;&nbsp;&nbsp;&nbsp;
	
	
	
	<a href="https://idreamshen.github.io/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>从 JDK Hotspot 源码探讨线程状态 <aside></aside></h1>
  <p>src/share/vm/classfile/javaClasses.hpp</p>

<pre><code class="language-cpp">// Java Thread Status for JVMTI and M&amp;M use.
// This thread status info is saved in threadStatus field of
// java.lang.Thread java class.
enum ThreadStatus {
  NEW                      = 0,
  RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
                             JVMTI_THREAD_STATE_RUNNABLE,
  SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_SLEEPING,
  IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                             JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
  IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
  PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                             JVMTI_THREAD_STATE_PARKED,
  PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_PARKED,
  BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
                             JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
  TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
};
</code></pre>

<p>src/share/vm/prims/jvmti.xml</p>

<pre><code class="language-xml">&lt;constants id=&quot;jvmtiThreadState&quot; label=&quot;Thread State Flags&quot; kind=&quot;bits&quot;&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_ALIVE&quot; num=&quot;0x0001&quot;&gt;
    Thread is alive. Zero if thread is new (not started) or terminated.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_TERMINATED&quot; num=&quot;0x0002&quot;&gt;
    Thread has completed execution.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_RUNNABLE&quot; num=&quot;0x0004&quot;&gt;
    Thread is runnable.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER&quot; num=&quot;0x0400&quot;&gt;
    Thread is waiting to enter a synchronization block/method or,
          after an &lt;code&gt;Object.wait()&lt;/code&gt;, waiting to re-enter a 
          synchronization block/method.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_WAITING&quot; num=&quot;0x0080&quot;&gt;
    Thread is waiting.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_WAITING_INDEFINITELY&quot; num=&quot;0x0010&quot;&gt;
    Thread is waiting without a timeout.
          For example, &lt;code&gt;Object.wait()&lt;/code&gt;.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT&quot; num=&quot;0x0020&quot;&gt;
    Thread is waiting with a maximum time to wait specified.
          For example, &lt;code&gt;Object.wait(long)&lt;/code&gt;.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_SLEEPING&quot; num=&quot;0x0040&quot;&gt;
    Thread is sleeping -- &lt;code&gt;Thread.sleep(long)&lt;/code&gt;.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_IN_OBJECT_WAIT&quot; num=&quot;0x0100&quot;&gt;
    Thread is waiting on an object monitor -- &lt;code&gt;Object.wait&lt;/code&gt;.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_PARKED&quot; num=&quot;0x0200&quot;&gt;
    Thread is parked, for example: &lt;code&gt;LockSupport.park&lt;/code&gt;,
          &lt;code&gt;LockSupport.parkUtil&lt;/code&gt; and &lt;code&gt;LockSupport.parkNanos&lt;/code&gt;.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_SUSPENDED&quot; num=&quot;0x100000&quot;&gt;
    Thread suspended.
    &lt;code&gt;java.lang.Thread.suspend()&lt;/code&gt;
    or a &lt;jvmti/&gt; suspend function 
          (such as &lt;functionlink id=&quot;SuspendThread&quot;&gt;&lt;/functionlink&gt;) 
          has been called on the thread. If this bit
    is set, the other bits refer to the thread state before suspension.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_INTERRUPTED&quot; num=&quot;0x200000&quot;&gt;
    Thread has been interrupted.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_IN_NATIVE&quot; num=&quot;0x400000&quot;&gt;
          Thread is in native code--that is, a native method is running
          which has not called back into the VM or Java programming
          language code.
          &lt;p/&gt;
          This flag is not set when running VM compiled Java programming
          language code nor is it set when running VM code or
          VM support code. Native VM interface functions, such as JNI and
          &lt;jvmti/&gt; functions, may be implemented as VM code.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_VENDOR_1&quot; num=&quot;0x10000000&quot;&gt;
          Defined by VM vendor.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_VENDOR_2&quot; num=&quot;0x20000000&quot;&gt;
          Defined by VM vendor.
  &lt;/constant&gt;
  &lt;constant id=&quot;JVMTI_THREAD_STATE_VENDOR_3&quot; num=&quot;0x40000000&quot;&gt;
          Defined by VM vendor.
  &lt;/constant&gt;
&lt;/constants&gt;
</code></pre>

<p>当一个线程的状态为 225 时，转换成 16 进制则为 e1。
按照公式：</p>

<pre><code>SLEEPING = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
           JVMTI_THREAD_STATE_WAITING +
           JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
           JVMTI_THREAD_STATE_SLEEPING
</code></pre>

<p>可以发现满足 e1 = 0x0001 + 0x0080 + 0x0020 + 0x0040（这4个数值与 jvmti.xml 一一对应），所以可以推断该线程当时处于 sleep 状态</p>

<p>另外 threadService.hpp 文件控制了一个线程的 threadStatus，比如 JavaThreadSleepState 该函数就将线程状态修改为 java_lang_Thread::SLEEPING</p>

<pre><code class="language-cpp">// Change status to sleeping
class JavaThreadSleepState : public JavaThreadStatusChanger {
 private:
  ThreadStatistics* _stat;
  bool _active;
 public:
  JavaThreadSleepState(JavaThread *java_thread) :
    JavaThreadStatusChanger(java_thread, java_lang_Thread::SLEEPING) {
    if (is_alive()) {
      _stat = java_thread-&gt;get_thread_stat();
      _active = ThreadService::is_thread_monitoring_contention();
      _stat-&gt;thread_sleep();
      if (_active) {
        _stat-&gt;thread_sleep_begin();
      }
    } else {
      _active = false;
    }
  }

  ~JavaThreadSleepState() {
    if (_active) {
      _stat-&gt;thread_sleep_end();
    }
  }
};
</code></pre>

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
