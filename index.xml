<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ChenHsingYu&#39;s Blog</title>
    <link>https://idreamshen.github.io/</link>
    <description>Recent content on ChenHsingYu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Mar 2018 14:56:06 +0800</lastBuildDate>
    
        <atom:link href="https://idreamshen.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何在国服使用 Apple News</title>
      <link>https://idreamshen.github.io/posts/how-to-use-apple-news-in-china/</link>
      <pubDate>Wed, 07 Mar 2018 14:56:06 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/how-to-use-apple-news-in-china/</guid>
      <description>&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;本文主要介绍如何使用 Apple News&lt;/p&gt;

&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;iPad&lt;/li&gt;
&lt;li&gt;梯子&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;首次操作-仅需操作一次&#34;&gt;首次操作（仅需操作一次）&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 iPad 地区改为美国地区&lt;/li&gt;
&lt;li&gt;将 iPad 语言改为英文&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;运行步骤&#34;&gt;运行步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开飞行模式&lt;/li&gt;
&lt;li&gt;连接无线网络，且确保自己的 iPad 网络处于梯子上&lt;/li&gt;
&lt;li&gt;找到 News 这个 APP，运行之，理论上就能正常展示新闻信息了&lt;/li&gt;
&lt;li&gt;关闭飞行模式&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;效果&#34;&gt;效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://idreamshen.github.io/image/apple-news.jpg&#34; alt=&#34;News App in iPad&#34; title=&#34;News App in iPad&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;备注&#34;&gt;备注&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上述飞行模式的切换不是必须的，但是切换飞行模式后能提高成功率&lt;/li&gt;
&lt;li&gt;不建议在 iPhone 上使用 News，iPhone 上运行 News 必须开启飞行模式&lt;/li&gt;
&lt;li&gt;一旦 News 加载新闻成功后，可以关闭梯子，因为 News 仅在启动时进行地域检测&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.v2ex.com/t/223846#r_2466757&#34; title=&#34;https://www.v2ex.com/t/223846#r_2466757&#34;&gt;https://www.v2ex.com/t/223846#r_2466757&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nodejs 鼠标点击</title>
      <link>https://idreamshen.github.io/posts/nodejs-mouse-click/</link>
      <pubDate>Tue, 16 Feb 2016 19:53:47 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/nodejs-mouse-click/</guid>
      <description>&lt;p&gt;今天玩 Clicker Heroes 的时候点鼠标点的累死,要是 mac 下也有个按键精灵就好了.在网上搜索一番后,找到了 robotjs 这个库,正和我意!&lt;/p&gt;

&lt;p&gt;于是,三行鼠标左键连点代码就有了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var robot = require(&amp;quot;robotjs&amp;quot;);

robot.setMouseDelay(80);

while (true) robot.mouseClick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以轻轻松松在 Clicker Heroes 中刷刷刷啦.&lt;/p&gt;

&lt;p&gt;robotjs 的 wiki 可以查阅: &lt;a href=&#34;https://github.com/octalmage/robotjs&#34;&gt;https://github.com/octalmage/robotjs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年终小结</title>
      <link>https://idreamshen.github.io/posts/2015-review/</link>
      <pubDate>Sat, 13 Feb 2016 12:12:49 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/2015-review/</guid>
      <description>&lt;p&gt;2015年是毕业后的第一年,工作经验终于增加了一年.这一年的努力如果要打个分的话,我给自己七分.这一年最大的变化是我能熟练的使用 Nodejs 开发各种项目以及开始学习了 Java.那接下来我就谈谈这一年里我对这两门语言的感受吧.&lt;/p&gt;

&lt;p&gt;Nodejs 是我这一年里使用次数最多的语言,我用它完成了若干个的项目.总结下来,用 Nodejs 开发有两个优点,开发快和性能高.我先说说开发快,由于 Nodejs 使用了 Javascript 这门语言作为编程语言, Javascript 的动态特性使得其在编写代码时非常简单.第二个优点是性能高,由于 Javascript 支持回调函数,使得异步IO并行操作,节省了大量的等待时间.但是 Nodejs 开发大型合作项目就有点麻烦了.一, IDE 无法很好地做到代码提示,二, 变量名方法名等重构困难.三, 弱类型很容易埋下了隐藏的漏洞.&lt;/p&gt;

&lt;p&gt;我举2个实例来看一下 Nodejs 和 Java 在编程上有什么区别.&lt;/p&gt;

&lt;p&gt;1.假设需求:通过一个网页向用户展示某件商品的相关信息.&lt;/p&gt;

&lt;p&gt;Nodejs 版 (Express Framework)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();
var Promise = require(&#39;bluebird&#39;);
var model = require(&#39;./models/index&#39;);

app.get(&#39;/item&#39;, function(req, res) {
    var itemId = req.query.itemId;
    var myUserId = req.session.userId;

    Promise.all([
        model.user.findById(myUserId),
        model.item.findById(itemId),
        model.itemDetail.findByItemId(itemId)
    ]).spread(function(user, item, itemDetail) {
        res.render(&#39;item&#39;, {
            me: user,
            item: item,
            itemDetail: itemDetail
        });
    }).catch(function(err) {
        res.render(&#39;error&#39;); // 渲染 error 页面
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 版 (Spring Boot Framework)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller
public class ItemController {
    @Autowired private UserRepository userRepository;
    @Autowired private ItemRepository itemRepository;
    @Autowired private ItemDetailRepository itemDetailRepository;

    @RequestMapping(method = RequestMethod.GET, path = &#39;/item&#39;)
    public String itemRender(@RequestParam(value = &amp;quot;itemId&amp;quot;, required = true) int itemId,
                            Model model) {

        Session session;
        // ...
        int userId = session.getUserId();

        UserModel userModel = userRepository.findOne(userId);
        ItemModel itemModel = itemRepository.findOne(itemId);
        ItemDetailModel itemDetailModel = itemDetailRepository.findByItemId(itemId);

        model.addAttribute(&#39;me&#39;, userModel);
        model.addAttribute(&#39;item&#39;, itemModel);
        model.addAttribute(&#39;itemDetail&#39;, itemDetail);

        return &amp;quot;shop/item&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nodejs 版中第 11 行至 13 行是从数据库获取信息,通过 Promise 的 all 方法包裹后,三个 sql 语句并行执行,假设 3 条 sql 语句耗时分别为 1ms 1.2ms 0.8ms,那么第 14 行的代码将在 1.2ms 后执行.再看 Java 版,第 15 行至 17 行是串行查询,所以第 19 行会在 1 + 1.2 + 0.8 = 3ms 后执行.这也就是一定程度上, Nodejs 的速度要优于 Java.&lt;/p&gt;

&lt;p&gt;2.假设需求:实现一个机器人简单逻辑&lt;/p&gt;

&lt;p&gt;Nodejs 版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Bot(id) {
    this.id = id;
}

// 说话
Bot.prototype.talk = function(message) {
    // ...
}

// 走路
Bot.prototype.walk = function(direction, step) {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Bot {
    private int id;

    public Bot(int id) {
        this.id = id;
    }

    public void talk(String message) {
        // ...
    }

    public void walk(Direction direction, int step) {
        // ...
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码结构来看几乎是差不多的,但是当你运行上百个上千个机器人时,就有点区别了.假设生成了1000个机器人. Nodejs 中每个机器人的不同的属性就是 id,其他方法都是相同的引用,也就是会创建1000 份 Bot 对象和 1 份 Bot 原型链上的方法.而在 Java 中会创建 1000 个 Bot Class.两者的内存占用相差是不小的.这是我的个人理解,可能有错误.&lt;/p&gt;

&lt;p&gt;以上两个例子似乎都在夸 Nodejs ,但是在实际使用中, Nodejs 并不是如此好驾驭的,上面我也提到了一些缺点. Nodejs 个人觉得适合小型项目比较好,比如说智能家居上面.对的,今天我花了五百大洋买了个树莓派,希望能把 Nodejs 折腾上去,那么用事件的模式去处理日常生活的各种指令应该是不错的体验(等待快递中 0.0).&lt;/p&gt;

&lt;p&gt;展望一下新的一年吧.由于工作上的需要,我可能得把更多的心思花到 Java 上了.为了不落下 Nodejs 的学习,我将尽可能的用 Nodejs 去编写树莓派上的各种应用.同时还要补一下编程的基础知识,编程的设计模式啦之类的.&lt;/p&gt;

&lt;p&gt;暂时就写到这吧.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sequelize 中的事务循环插入</title>
      <link>https://idreamshen.github.io/posts/sequelize-transaction/</link>
      <pubDate>Thu, 13 Aug 2015 16:14:13 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/sequelize-transaction/</guid>
      <description>&lt;p&gt;sequelize 的事务模式详细使用方法可以参考官方文档
&lt;a href=&#34;http://docs.sequelizejs.com/en/latest/docs/transactions&#34;&gt;http://docs.sequelizejs.com/en/latest/docs/transactions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍一下如何在 sequelize 的事务中进行循环插入。
假设有两个模型 Order 和 OrderItem，一条 Order 记录会对应若干条 OrderItem 记录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Promsise = require(&#39;bluebird&#39;);


function insert () {
  var itemIds = [1,2,3];

  return sequelize.transaction(function (t){
    return Order.create({
      name: &#39;XXX订单&#39;,
      price: 100
    }, {transaction: t}).then(function (order){
      return Promise.map(itemIds, function(itemId) {
        return OrderItem.create({
          order_id: order.get(&#39;id&#39;),
          item_id: itemId
        }, {transaction: t});
      });
    });
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决的方案就是采用 Promise.map 这个方法，它能遍历数组并返回 promise。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket.io 中一些有用的方法</title>
      <link>https://idreamshen.github.io/posts/socket-io-some-useful-funcs/</link>
      <pubDate>Tue, 11 Aug 2015 16:08:32 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/socket-io-some-useful-funcs/</guid>
      <description>

&lt;h3 id=&#34;io-use&#34;&gt;io.use&lt;/h3&gt;

&lt;p&gt;注册中间件。看一下下面的这个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) return next(); // 如果密码正确，则执行返回 next()
  next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
});

/** 监听事件 **/
io.on(&#39;connection&#39;, function (socket) {
  socket.on(&#39;disconnect&#39;, function () {
    // 客户端断线
  });

  socket.on(&#39;message&#39;, function (body) {
    // 服务器收到客户端发来的消息
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 客户端代码
&amp;lt;script src=&#39;https://idreamshen.github.io/socket.io/socket.io.js&#39;&amp;gt;&amp;lt;/script&amp;gt; // 加载 socket.io.js
&amp;lt;script&amp;gt;
  var socket = io(&#39;http://localhost&#39;, {query: &#39;password=654321&#39;}); // 实例化并连接到 socket 服务器，传入密码参数

  /** 监听 error 事件 **/
  socket.on(&#39;error&#39;, function (err) {
    console.log(err); // 打印 err，注：err 是字符串类型
  });

  socket.send(&#39;hello server&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，当客户端尝试连接服务器时，因为传入的密码是 654321，导致服务端的中间件认证失败，触发客户端的 error 事件。客户端代码第 8 行会打印出“密码错误”这几个字。&lt;/p&gt;

&lt;p&gt;注意服务端代码中第 9 行的 return 不能省略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) next(); // 如果密码正确，则执行返回 next()
  next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意第 9 行，如果省略 return，则会导致第 10 行代码也被执行。可以将代码修改成下面的更易理解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) {
    next(); // 如果密码正确，则执行返回 next()
  } else {
    next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ack-模式&#34;&gt;ACK 模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端
var io = require(&#39;socket.io&#39;)();

io.on(&#39;connection&#39;, function (socket) {
  socket.on(&#39;chat&#39;, function (msg, callback) {
    callback({
      success: true
    });
    io.emit(&#39;chat&#39;, msg);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 客户端
&amp;lt;script&amp;gt;
  var socket = io();
  socket.on(&#39;connect&#39;, function () {
    socket.emit(&#39;chat&#39;, &#39;Hello&#39;, function (response) {
      console.log(response.success); // 打印结果为 true
    });

    socket.on(&#39;chat&#39;, function (response) {
      console.log(response); // 打印结果为 Hello
    });
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Redis 几个常用的简单命令</title>
      <link>https://idreamshen.github.io/posts/redis-func/</link>
      <pubDate>Tue, 11 Aug 2015 15:27:19 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/redis-func/</guid>
      <description>

&lt;h3 id=&#34;redis-cli&#34;&gt;redis-cli&lt;/h3&gt;

&lt;p&gt;连接数据库
例子：&lt;code&gt;redis-cli&lt;/code&gt; 连接到本地
例子：&lt;code&gt;redis-cli -h 192.168.1.27&lt;/code&gt; 连接到远程&lt;/p&gt;

&lt;h3 id=&#34;type&#34;&gt;type&lt;/h3&gt;

&lt;p&gt;查看某个 key 的类型
例子：&lt;code&gt;type key&lt;/code&gt;，返回的结果可能有 &lt;code&gt;string&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;，&lt;code&gt;list&lt;/code&gt; 等&lt;/p&gt;

&lt;h3 id=&#34;keys&#34;&gt;keys&lt;/h3&gt;

&lt;p&gt;查看所有的 key
例子：&lt;code&gt;keys *&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;smembers&#34;&gt;smembers&lt;/h3&gt;

&lt;p&gt;查看某个 sets 类型的所有成员
例子：&lt;code&gt;smembers key&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;hgetall&#34;&gt;hgetall&lt;/h3&gt;

&lt;p&gt;查看某个 hash 类型的所有成员
例子：&lt;code&gt;hgetall key&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Hexo</title>
      <link>https://idreamshen.github.io/posts/hello-world/</link>
      <pubDate>Tue, 11 Aug 2015 14:46:57 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/hello-world/</guid>
      <description>&lt;p&gt;今天用了下 Hexo，很爽，简洁明了的博客系统。就在这记录些我自己平时的所见所闻吧。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>