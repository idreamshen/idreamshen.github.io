<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ChenHsingYu&#39;s Blog</title>
    <link>https://idreamshen.github.io/</link>
    <description>Recent content on ChenHsingYu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 20 Apr 2018 16:14:14 +0800</lastBuildDate>
    
        <atom:link href="https://idreamshen.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何观看 Netflix</title>
      <link>https://idreamshen.github.io/posts/how-to-watch-netflix/</link>
      <pubDate>Fri, 20 Apr 2018 16:14:14 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/how-to-watch-netflix/</guid>
      <description>&lt;p&gt;前段时间用某云的 HK 节点自建梯子观看 Netflix 很流畅，但是最近发现 HK 节点已无法正常观看。更换了该云上的 IP 后依然无法正常观看。&lt;/p&gt;

&lt;p&gt;经过一番折腾，找到了一家不错的梯子，可以顺利观看 Netflix，下面就简要介绍一番。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务商为 &lt;a href=&#34;https://hkssnetwork.net/&#34; title=&#34;https://hkssnetwork.net/&#34;&gt;https://hkssnetwork.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;注册 hkss 账号&lt;/li&gt;
&lt;li&gt;充值 11 元&lt;/li&gt;
&lt;li&gt;购买最低配的 50G 流量套餐&lt;/li&gt;
&lt;li&gt;在 iPad 上使用梯子连接新的服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://idreamshen.github.io/image/netflix.jpg&#34; alt=&#34;netflix.jpg&#34; title=&#34;netflix.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;由于 Netflix 无法截图播放界面，但是实测播放相当流畅，hava fun~&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 GIT 克隆指定 TAG 或分支</title>
      <link>https://idreamshen.github.io/posts/git-clone-specific-tag-or-branch/</link>
      <pubDate>Sat, 14 Apr 2018 15:33:31 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/git-clone-specific-tag-or-branch/</guid>
      <description>&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
git clone -b &#39;v2.0&#39; --single-branch --depth 1 https://github.com/git/git.git
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;v2.0 代指 branch 或 tag&lt;/li&gt;
&lt;li&gt;depth 表示 clone 深度，如果待克隆的项目很大，同时您不关注代码的变更历史，那可以使用 depth=1 提高 clone 速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/791959/download-a-specific-tag-with-git?utm_medium%3Dorganic&amp;amp;utm_source%3Dgoogle_rich_qa&amp;amp;utm_campaign%3Dgoogle_rich_qa&#34; title=&#34;Download a specific tag with Git&#34;&gt;Download a specific tag with Git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>从 JDK Hotspot 源码探讨线程状态</title>
      <link>https://idreamshen.github.io/posts/thread-status-from-jdk-hotspot/</link>
      <pubDate>Wed, 11 Apr 2018 13:54:13 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/thread-status-from-jdk-hotspot/</guid>
      <description>&lt;p&gt;src/share/vm/classfile/javaClasses.hpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
// Java Thread Status for JVMTI and M&amp;amp;M use.
// This thread status info is saved in threadStatus field of
// java.lang.Thread java class.
enum ThreadStatus {
  NEW                      = 0,
  RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
                             JVMTI_THREAD_STATE_RUNNABLE,
  SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_SLEEPING,
  IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                             JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
  IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
  PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                             JVMTI_THREAD_STATE_PARKED,
  PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
                             JVMTI_THREAD_STATE_WAITING +
                             JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                             JVMTI_THREAD_STATE_PARKED,
  BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
                             JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
  TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;src/share/vm/prims/jvmti.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;constants id=&amp;quot;jvmtiThreadState&amp;quot; label=&amp;quot;Thread State Flags&amp;quot; kind=&amp;quot;bits&amp;quot;&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_ALIVE&amp;quot; num=&amp;quot;0x0001&amp;quot;&amp;gt;
    Thread is alive. Zero if thread is new (not started) or terminated.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_TERMINATED&amp;quot; num=&amp;quot;0x0002&amp;quot;&amp;gt;
    Thread has completed execution.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_RUNNABLE&amp;quot; num=&amp;quot;0x0004&amp;quot;&amp;gt;
    Thread is runnable.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER&amp;quot; num=&amp;quot;0x0400&amp;quot;&amp;gt;
    Thread is waiting to enter a synchronization block/method or,
          after an &amp;lt;code&amp;gt;Object.wait()&amp;lt;/code&amp;gt;, waiting to re-enter a 
          synchronization block/method.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_WAITING&amp;quot; num=&amp;quot;0x0080&amp;quot;&amp;gt;
    Thread is waiting.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_WAITING_INDEFINITELY&amp;quot; num=&amp;quot;0x0010&amp;quot;&amp;gt;
    Thread is waiting without a timeout.
          For example, &amp;lt;code&amp;gt;Object.wait()&amp;lt;/code&amp;gt;.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT&amp;quot; num=&amp;quot;0x0020&amp;quot;&amp;gt;
    Thread is waiting with a maximum time to wait specified.
          For example, &amp;lt;code&amp;gt;Object.wait(long)&amp;lt;/code&amp;gt;.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_SLEEPING&amp;quot; num=&amp;quot;0x0040&amp;quot;&amp;gt;
    Thread is sleeping -- &amp;lt;code&amp;gt;Thread.sleep(long)&amp;lt;/code&amp;gt;.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_IN_OBJECT_WAIT&amp;quot; num=&amp;quot;0x0100&amp;quot;&amp;gt;
    Thread is waiting on an object monitor -- &amp;lt;code&amp;gt;Object.wait&amp;lt;/code&amp;gt;.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_PARKED&amp;quot; num=&amp;quot;0x0200&amp;quot;&amp;gt;
    Thread is parked, for example: &amp;lt;code&amp;gt;LockSupport.park&amp;lt;/code&amp;gt;,
          &amp;lt;code&amp;gt;LockSupport.parkUtil&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;LockSupport.parkNanos&amp;lt;/code&amp;gt;.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_SUSPENDED&amp;quot; num=&amp;quot;0x100000&amp;quot;&amp;gt;
    Thread suspended.
    &amp;lt;code&amp;gt;java.lang.Thread.suspend()&amp;lt;/code&amp;gt;
    or a &amp;lt;jvmti/&amp;gt; suspend function 
          (such as &amp;lt;functionlink id=&amp;quot;SuspendThread&amp;quot;&amp;gt;&amp;lt;/functionlink&amp;gt;) 
          has been called on the thread. If this bit
    is set, the other bits refer to the thread state before suspension.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_INTERRUPTED&amp;quot; num=&amp;quot;0x200000&amp;quot;&amp;gt;
    Thread has been interrupted.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_IN_NATIVE&amp;quot; num=&amp;quot;0x400000&amp;quot;&amp;gt;
          Thread is in native code--that is, a native method is running
          which has not called back into the VM or Java programming
          language code.
          &amp;lt;p/&amp;gt;
          This flag is not set when running VM compiled Java programming
          language code nor is it set when running VM code or
          VM support code. Native VM interface functions, such as JNI and
          &amp;lt;jvmti/&amp;gt; functions, may be implemented as VM code.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_VENDOR_1&amp;quot; num=&amp;quot;0x10000000&amp;quot;&amp;gt;
          Defined by VM vendor.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_VENDOR_2&amp;quot; num=&amp;quot;0x20000000&amp;quot;&amp;gt;
          Defined by VM vendor.
  &amp;lt;/constant&amp;gt;
  &amp;lt;constant id=&amp;quot;JVMTI_THREAD_STATE_VENDOR_3&amp;quot; num=&amp;quot;0x40000000&amp;quot;&amp;gt;
          Defined by VM vendor.
  &amp;lt;/constant&amp;gt;
&amp;lt;/constants&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个线程的状态为 225 时，转换成 16 进制则为 e1。
按照公式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
SLEEPING = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
           JVMTI_THREAD_STATE_WAITING +
           JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
           JVMTI_THREAD_STATE_SLEEPING
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现满足 e1 = 0x0001 + 0x0080 + 0x0020 + 0x0040（这4个数值与 jvmti.xml 一一对应），所以可以推断该线程当时处于 sleep 状态&lt;/p&gt;

&lt;p&gt;另外 threadService.hpp 文件控制了一个线程的 threadStatus，比如 JavaThreadSleepState 该函数就将线程状态修改为 java_lang_Thread::SLEEPING&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
// Change status to sleeping
class JavaThreadSleepState : public JavaThreadStatusChanger {
 private:
  ThreadStatistics* _stat;
  bool _active;
 public:
  JavaThreadSleepState(JavaThread *java_thread) :
    JavaThreadStatusChanger(java_thread, java_lang_Thread::SLEEPING) {
    if (is_alive()) {
      _stat = java_thread-&amp;gt;get_thread_stat();
      _active = ThreadService::is_thread_monitoring_contention();
      _stat-&amp;gt;thread_sleep();
      if (_active) {
        _stat-&amp;gt;thread_sleep_begin();
      }
    } else {
      _active = false;
    }
  }

  ~JavaThreadSleepState() {
    if (_active) {
      _stat-&amp;gt;thread_sleep_end();
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>如何在国服使用 Apple News</title>
      <link>https://idreamshen.github.io/posts/how-to-use-apple-news-in-china/</link>
      <pubDate>Wed, 07 Mar 2018 14:56:06 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/how-to-use-apple-news-in-china/</guid>
      <description>&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;本文主要介绍如何使用 Apple News&lt;/p&gt;

&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;iPad&lt;/li&gt;
&lt;li&gt;梯子&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;首次操作-仅需操作一次&#34;&gt;首次操作（仅需操作一次）&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 iPad 地区改为美国地区&lt;/li&gt;
&lt;li&gt;将 iPad 语言改为英文&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;运行步骤&#34;&gt;运行步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开飞行模式&lt;/li&gt;
&lt;li&gt;连接无线网络，且确保自己的 iPad 网络处于梯子上&lt;/li&gt;
&lt;li&gt;找到 News 这个 APP，运行之，理论上就能正常展示新闻信息了&lt;/li&gt;
&lt;li&gt;关闭飞行模式&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;效果&#34;&gt;效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://idreamshen.github.io/image/apple-news.jpg&#34; alt=&#34;News App in iPad&#34; title=&#34;News App in iPad&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;备注&#34;&gt;备注&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上述飞行模式的切换不是必须的，但是切换飞行模式后能提高成功率&lt;/li&gt;
&lt;li&gt;不建议在 iPhone 上使用 News，iPhone 上运行 News 必须开启飞行模式&lt;/li&gt;
&lt;li&gt;一旦 News 加载新闻成功后，可以关闭梯子，因为 News 仅在启动时进行地域检测&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.v2ex.com/t/223846#r_2466757&#34; title=&#34;https://www.v2ex.com/t/223846#r_2466757&#34;&gt;https://www.v2ex.com/t/223846#r_2466757&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nodejs 鼠标点击</title>
      <link>https://idreamshen.github.io/posts/nodejs-mouse-click/</link>
      <pubDate>Tue, 16 Feb 2016 19:53:47 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/nodejs-mouse-click/</guid>
      <description>&lt;p&gt;今天玩 Clicker Heroes 的时候点鼠标点的累死,要是 mac 下也有个按键精灵就好了.在网上搜索一番后,找到了 robotjs 这个库,正和我意!&lt;/p&gt;

&lt;p&gt;于是,三行鼠标左键连点代码就有了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var robot = require(&amp;quot;robotjs&amp;quot;);

robot.setMouseDelay(80);

while (true) robot.mouseClick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以轻轻松松在 Clicker Heroes 中刷刷刷啦.&lt;/p&gt;

&lt;p&gt;robotjs 的 wiki 可以查阅: &lt;a href=&#34;https://github.com/octalmage/robotjs&#34;&gt;https://github.com/octalmage/robotjs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年终小结</title>
      <link>https://idreamshen.github.io/posts/2015-review/</link>
      <pubDate>Sat, 13 Feb 2016 12:12:49 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/2015-review/</guid>
      <description>&lt;p&gt;2015年是毕业后的第一年,工作经验终于增加了一年.这一年的努力如果要打个分的话,我给自己七分.这一年最大的变化是我能熟练的使用 Nodejs 开发各种项目以及开始学习了 Java.那接下来我就谈谈这一年里我对这两门语言的感受吧.&lt;/p&gt;

&lt;p&gt;Nodejs 是我这一年里使用次数最多的语言,我用它完成了若干个的项目.总结下来,用 Nodejs 开发有两个优点,开发快和性能高.我先说说开发快,由于 Nodejs 使用了 Javascript 这门语言作为编程语言, Javascript 的动态特性使得其在编写代码时非常简单.第二个优点是性能高,由于 Javascript 支持回调函数,使得异步IO并行操作,节省了大量的等待时间.但是 Nodejs 开发大型合作项目就有点麻烦了.一, IDE 无法很好地做到代码提示,二, 变量名方法名等重构困难.三, 弱类型很容易埋下了隐藏的漏洞.&lt;/p&gt;

&lt;p&gt;我举2个实例来看一下 Nodejs 和 Java 在编程上有什么区别.&lt;/p&gt;

&lt;p&gt;1.假设需求:通过一个网页向用户展示某件商品的相关信息.&lt;/p&gt;

&lt;p&gt;Nodejs 版 (Express Framework)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();
var Promise = require(&#39;bluebird&#39;);
var model = require(&#39;./models/index&#39;);

app.get(&#39;/item&#39;, function(req, res) {
    var itemId = req.query.itemId;
    var myUserId = req.session.userId;

    Promise.all([
        model.user.findById(myUserId),
        model.item.findById(itemId),
        model.itemDetail.findByItemId(itemId)
    ]).spread(function(user, item, itemDetail) {
        res.render(&#39;item&#39;, {
            me: user,
            item: item,
            itemDetail: itemDetail
        });
    }).catch(function(err) {
        res.render(&#39;error&#39;); // 渲染 error 页面
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 版 (Spring Boot Framework)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller
public class ItemController {
    @Autowired private UserRepository userRepository;
    @Autowired private ItemRepository itemRepository;
    @Autowired private ItemDetailRepository itemDetailRepository;

    @RequestMapping(method = RequestMethod.GET, path = &#39;/item&#39;)
    public String itemRender(@RequestParam(value = &amp;quot;itemId&amp;quot;, required = true) int itemId,
                            Model model) {

        Session session;
        // ...
        int userId = session.getUserId();

        UserModel userModel = userRepository.findOne(userId);
        ItemModel itemModel = itemRepository.findOne(itemId);
        ItemDetailModel itemDetailModel = itemDetailRepository.findByItemId(itemId);

        model.addAttribute(&#39;me&#39;, userModel);
        model.addAttribute(&#39;item&#39;, itemModel);
        model.addAttribute(&#39;itemDetail&#39;, itemDetail);

        return &amp;quot;shop/item&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nodejs 版中第 11 行至 13 行是从数据库获取信息,通过 Promise 的 all 方法包裹后,三个 sql 语句并行执行,假设 3 条 sql 语句耗时分别为 1ms 1.2ms 0.8ms,那么第 14 行的代码将在 1.2ms 后执行.再看 Java 版,第 15 行至 17 行是串行查询,所以第 19 行会在 1 + 1.2 + 0.8 = 3ms 后执行.这也就是一定程度上, Nodejs 的速度要优于 Java.&lt;/p&gt;

&lt;p&gt;2.假设需求:实现一个机器人简单逻辑&lt;/p&gt;

&lt;p&gt;Nodejs 版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Bot(id) {
    this.id = id;
}

// 说话
Bot.prototype.talk = function(message) {
    // ...
}

// 走路
Bot.prototype.walk = function(direction, step) {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Bot {
    private int id;

    public Bot(int id) {
        this.id = id;
    }

    public void talk(String message) {
        // ...
    }

    public void walk(Direction direction, int step) {
        // ...
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码结构来看几乎是差不多的,但是当你运行上百个上千个机器人时,就有点区别了.假设生成了1000个机器人. Nodejs 中每个机器人的不同的属性就是 id,其他方法都是相同的引用,也就是会创建1000 份 Bot 对象和 1 份 Bot 原型链上的方法.而在 Java 中会创建 1000 个 Bot Class.两者的内存占用相差是不小的.这是我的个人理解,可能有错误.&lt;/p&gt;

&lt;p&gt;以上两个例子似乎都在夸 Nodejs ,但是在实际使用中, Nodejs 并不是如此好驾驭的,上面我也提到了一些缺点. Nodejs 个人觉得适合小型项目比较好,比如说智能家居上面.对的,今天我花了五百大洋买了个树莓派,希望能把 Nodejs 折腾上去,那么用事件的模式去处理日常生活的各种指令应该是不错的体验(等待快递中 0.0).&lt;/p&gt;

&lt;p&gt;展望一下新的一年吧.由于工作上的需要,我可能得把更多的心思花到 Java 上了.为了不落下 Nodejs 的学习,我将尽可能的用 Nodejs 去编写树莓派上的各种应用.同时还要补一下编程的基础知识,编程的设计模式啦之类的.&lt;/p&gt;

&lt;p&gt;暂时就写到这吧.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sequelize 中的事务循环插入</title>
      <link>https://idreamshen.github.io/posts/sequelize-transaction/</link>
      <pubDate>Thu, 13 Aug 2015 16:14:13 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/sequelize-transaction/</guid>
      <description>&lt;p&gt;sequelize 的事务模式详细使用方法可以参考官方文档
&lt;a href=&#34;http://docs.sequelizejs.com/en/latest/docs/transactions&#34;&gt;http://docs.sequelizejs.com/en/latest/docs/transactions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍一下如何在 sequelize 的事务中进行循环插入。
假设有两个模型 Order 和 OrderItem，一条 Order 记录会对应若干条 OrderItem 记录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Promsise = require(&#39;bluebird&#39;);


function insert () {
  var itemIds = [1,2,3];

  return sequelize.transaction(function (t){
    return Order.create({
      name: &#39;XXX订单&#39;,
      price: 100
    }, {transaction: t}).then(function (order){
      return Promise.map(itemIds, function(itemId) {
        return OrderItem.create({
          order_id: order.get(&#39;id&#39;),
          item_id: itemId
        }, {transaction: t});
      });
    });
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决的方案就是采用 Promise.map 这个方法，它能遍历数组并返回 promise。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket.io 中一些有用的方法</title>
      <link>https://idreamshen.github.io/posts/socket-io-some-useful-funcs/</link>
      <pubDate>Tue, 11 Aug 2015 16:08:32 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/socket-io-some-useful-funcs/</guid>
      <description>

&lt;h3 id=&#34;io-use&#34;&gt;io.use&lt;/h3&gt;

&lt;p&gt;注册中间件。看一下下面的这个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) return next(); // 如果密码正确，则执行返回 next()
  next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
});

/** 监听事件 **/
io.on(&#39;connection&#39;, function (socket) {
  socket.on(&#39;disconnect&#39;, function () {
    // 客户端断线
  });

  socket.on(&#39;message&#39;, function (body) {
    // 服务器收到客户端发来的消息
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 客户端代码
&amp;lt;script src=&#39;https://idreamshen.github.io/socket.io/socket.io.js&#39;&amp;gt;&amp;lt;/script&amp;gt; // 加载 socket.io.js
&amp;lt;script&amp;gt;
  var socket = io(&#39;http://localhost&#39;, {query: &#39;password=654321&#39;}); // 实例化并连接到 socket 服务器，传入密码参数

  /** 监听 error 事件 **/
  socket.on(&#39;error&#39;, function (err) {
    console.log(err); // 打印 err，注：err 是字符串类型
  });

  socket.send(&#39;hello server&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，当客户端尝试连接服务器时，因为传入的密码是 654321，导致服务端的中间件认证失败，触发客户端的 error 事件。客户端代码第 8 行会打印出“密码错误”这几个字。&lt;/p&gt;

&lt;p&gt;注意服务端代码中第 9 行的 return 不能省略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) next(); // 如果密码正确，则执行返回 next()
  next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意第 9 行，如果省略 return，则会导致第 10 行代码也被执行。可以将代码修改成下面的更易理解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端代码
var io = require(&#39;socket.io&#39;)(); // 引用 socket.io 库并实例化

/** 注册中间件 **/
io.use(function (socket, next) {
  var query = socket.handshake.query; // 获取客户端的连接 url 中的参数
  var password = query.password; // 读取参数中密码

  if (password === &#39;123456&#39;) {
    next(); // 如果密码正确，则执行返回 next()
  } else {
    next(new Error(&#39;密码错误&#39;)); // 如果密码错误，则抛出异常
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ack-模式&#34;&gt;ACK 模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 服务端
var io = require(&#39;socket.io&#39;)();

io.on(&#39;connection&#39;, function (socket) {
  socket.on(&#39;chat&#39;, function (msg, callback) {
    callback({
      success: true
    });
    io.emit(&#39;chat&#39;, msg);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 客户端
&amp;lt;script&amp;gt;
  var socket = io();
  socket.on(&#39;connect&#39;, function () {
    socket.emit(&#39;chat&#39;, &#39;Hello&#39;, function (response) {
      console.log(response.success); // 打印结果为 true
    });

    socket.on(&#39;chat&#39;, function (response) {
      console.log(response); // 打印结果为 Hello
    });
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Redis 几个常用的简单命令</title>
      <link>https://idreamshen.github.io/posts/redis-func/</link>
      <pubDate>Tue, 11 Aug 2015 15:27:19 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/redis-func/</guid>
      <description>

&lt;h3 id=&#34;redis-cli&#34;&gt;redis-cli&lt;/h3&gt;

&lt;p&gt;连接数据库
例子：&lt;code&gt;redis-cli&lt;/code&gt; 连接到本地
例子：&lt;code&gt;redis-cli -h 192.168.1.27&lt;/code&gt; 连接到远程&lt;/p&gt;

&lt;h3 id=&#34;type&#34;&gt;type&lt;/h3&gt;

&lt;p&gt;查看某个 key 的类型
例子：&lt;code&gt;type key&lt;/code&gt;，返回的结果可能有 &lt;code&gt;string&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;，&lt;code&gt;list&lt;/code&gt; 等&lt;/p&gt;

&lt;h3 id=&#34;keys&#34;&gt;keys&lt;/h3&gt;

&lt;p&gt;查看所有的 key
例子：&lt;code&gt;keys *&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;smembers&#34;&gt;smembers&lt;/h3&gt;

&lt;p&gt;查看某个 sets 类型的所有成员
例子：&lt;code&gt;smembers key&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;hgetall&#34;&gt;hgetall&lt;/h3&gt;

&lt;p&gt;查看某个 hash 类型的所有成员
例子：&lt;code&gt;hgetall key&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Hexo</title>
      <link>https://idreamshen.github.io/posts/hello-world/</link>
      <pubDate>Tue, 11 Aug 2015 14:46:57 +0800</pubDate>
      
      <guid>https://idreamshen.github.io/posts/hello-world/</guid>
      <description>&lt;p&gt;今天用了下 Hexo，很爽，简洁明了的博客系统。就在这记录些我自己平时的所见所闻吧。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>